
 „УЕБ ПРИЛОЖЕНИЕ В СФЕРАТА НА ГЕЙМИНГ ПРОДУКТИТЕ“
ДИМИТЪР ДУКОВ


  ДЪРЖАВЕН ИЗПИТ
ЗА ПРИДОБИВАНЕ НА ТРЕТА СТЕПЕН НА ПРОФЕСИОНАЛНА КВАЛИФИКАЦИЯ –ЧАСТ ПО ТЕОРИЯ НА ПРОФЕСИЯТА






Д И П Л О М Е Н  П Р О Е К Т






Тема: „Разработване на уеб базирано приложение в сферата на гейминг продуктите“






професия: 481020 „Системен програмист“
специалност: 4810201 „Системно програмиране“




Дипломант: Димитър Митков Дуков, 12А клас
Ръководител на дипломния проект: инж. Веселина Стефанова Маринова








Подпис:
(дипломант)
Подпис:
(ръководител)






София, 2024 г.




Съдържание




1        Въведение        3
1.1        Задание за разработка        3
1.2        Анализ на заданието        3
1.3        Поставени цели        4
2        Основна част        5
2.1.        Избор на технологии        5
   2.1.1           Избор на технология за потребителската част        5
   2.1.2           Избор на технология за сървъра        8
   2.1.3           Избор на технология за базата данни        10
2.2.        Софтуерен дизайн        11
   2.2.1           Етапи на разработка        11
   2.2.2           Софтуерна архитектура        14
   2.2.3           Описание и взаимодействие с приложението        16
   2.2.4           Графичен дизайн и структура на приложението        20
   2.2.5           Дизайн на сървъра        23
   2.2.6           Дизайн на базата данни        26
   2.2.7           CRUD заявки        31
2.3        Тестване        34
3        Заключение        34
3.1        Постигнати цели        34
3.2        Потенциално развитие        35
4        Източници        37
5        Приложение        38






        
        


1. Въведение


   1. Задание за разработка


Technoworld е иновативно уеб базирано приложение, разработено с използването на широк спектър от технологии, включително HTML, CSS, TypeScript и Astro за фронт-енд разработка, както и Node.js и Express.js за бeк-енд функционалности. Използването на MYSQL като система за управление на релационни бази данни и Sequelize като обектно релационен картограф (Object Relational Mapper) допринася за ефективното съхранение и управление на данните на платформата. Това уеб приложение е специализирано в продажбата на гейминг хардуерни продукти, включващи лаптопи, компютри, смартфони и други устройства.
Уеб приложението предоставя на своите потребители възможността да закупят най-новите и иновативни продукти от този така динамичен и изящен пазар. Тези продукти са проектирани да осигурят на потребителите незабравимо преживяване в сферата на гейминга и не само, като предлаганите продукти отговарят на техните разнообразни изисквания и предпочитания. 
Уебсайта предлага широка гама от продукти, които отговарят на нуждите и предпочитанията както на геймърите на всички нива - от начинаещи до професионалисти, така и на обикновените не-геймър потребители. Тук потребителите могат да намерят всичко, от високотехнологични компютърни системи и гейминг лаптопи до модерни смартфони и аксесоари, които подобряват техния ежедневен живот.


   2. Анализ на заданието


В Technoworld потребителите ще имат възможност да създават свои персонализирани акаунти, или да разглеждат сайта като гости (по подразбиране), като гостите обаче ще имат лимитирана функционалност. Това ще бъде направено с цел насърчаване създаване на повече индивидуални профили, чрез които ще се изследват предпочитанията на потребителите с повече детайли,[a] за да може да се предлагат по-персонализирани продукти за тях. Също така това приложение ще предоставя възможност за добавяне на конкретни продукти към списък с желани продукти (wishlist) или към количка, позволяващо по-лесен достъп до определени продукти и управление на планираните покупки на клиента. Освен това потребителите ще могат да разглеждат информация за техните направени поръчки и също така да проследяват техният статус, като те могат да видят дали тяхната поръчка е в процес на изпълнение, изпратена, получена или завършена напълно.


Приложението ще предлага и различни функции, налични в повечето подобни уеб магазини, като: търсене на конкретни продукти чрез конкретно въведени от потребителя ключови думи, име или част от спецификация на продукта; филтриране на продуктите по различни критерии, като марка, спецификации и рейтинг; сортиране на продукти по зададени критерии, като цена (възходяща или низходяща), име (от A до Z или от Z-до A) и т.н.
Освен това уеб магазинът ще притежава и една уникална функция - а именно интегрирана система за наддаване на цената на специално избрани от администратора продукти. Това е специална и невиждана досега интеграция за уеб магазин, като се инспирирах да я имплементирам, след като видях друг подобен проект. Уеб приложението също така ще прилага напълно responsive дизайн, с цел да бъде достъпен за колкото се може повече потребители и устройства, за да може максимално да увеличи своя потенциален клиентски обхват.


   3. Поставени цели


Целта на настоящата дипломна работа е да се създаде иновативно и адаптивно уеб приложение, което да предложи на потребителите най-доброто потребителско изживяване, независимо от устройството, което използват. В този контекст, основната задача е да се разработи уеб платформа с чист, разбираем и лесен за поддръжка код, което ще допринесе за оптималното функциониране и разширяване на приложението. В същото време, целта е да се създаде удобен и интуитивен за ползване интерфейс, който да предостави на потребителите лесна навигация и приятно изживяване при използване на платформата.
В допълнение към този интерфейс, приложението също така трябва да предоставя и възможност за търсене на продукти. Тази функционалност ще бъде създадена със специално внимание към лесното използване и ще предоставя на потребителите разнообразни критерии за търсене, като ключови думи, име, цена, категории, спецификации и др., с цел ефективно търсене и намиране на най-подходящите продукти за всеки един потребител. 
Целта е да се осигури на потребителите широк набор от възможности, които да ги подпомогнат в бързото и ефективно намиране на желаните от тях продукти.
Приложението ще бъде създадено с акцент върху responsive дизайна, което ще гарантира, че потребителите могат да използват платформата навсякъде, по всяко време и на всяко устройство. Също така приложението ще предложи интуитивна навигация, за да се улесни потребителското изживяване и да се осигури на потребителите гладка и приятна интеракция с приложението.
Освен това приложението трябва да предлага възможност за оценяване на продуктите, с цел потребителите да изразят своето мнение, дали положително или отрицателно, за дадения продукт. Това трябва да се направи, за да може клинетите да имат повече информация за надеждността и популярността на даден продукт, и също така за мнението на другите хора, които вече са използвали този продукт.
Не на последно място трябва да се създаде и функционалността за наддаване на специални продукти, с цел създаване на допълнителен елемент на ангажимент и вълнение за потребителите, като им се предоставя възможността да участват в интерактивен процес за придобиване на желаните продукти. В допълнение тази уникална функционалност ще стимулира ангажираността и взаимодействието с приложението, което ще повиши потребителското удовлетворение и лоялността към компанията, и също така ще увеличи интереса към специалните продукти и ще ги направи по-желани и искани от потребителите.
Със съчетаването на гореспоменатите цели, платформата ще предложи на своите потребители удобство, ефективност и удоволствие при търсенето, пазаруването и наддаването на гейминг продукти, като по този начин ще задоволи нуждите и очакванията на целевата аудитория.[b]


2. Основна част


   4. Избор на технологии


      1. Избор на технология за потребителската част


HTML (Hypertext Markup Language) е в основата на всяко уеб приложение, включително и на този онлайн магазин. Той е основният език за маркиране, който се използва за дефиниране на структурата и съдържанието на уеб страници, 
като включва различни елементи като заглавия, параграфи, списъци, таблиц и много други. 
CSS (Cascading Style Sheets) се използва за стилизиране и оформление на уеб страници и уеб приложения. Той позволява на разработчиците да дефинират външния вид на елементите, определяйки техния цвят, шрифт, размер, позициониране и други визуални свойства. CSS се използва за управление на визуалния аспект на уебсайта, като го прави по-привлекателен за потребителите и подобрява изживяването им.
TypeScript е суперсет на JavaScript, който добавя статично типизиране към езика. Избрах да използвам TypeScript, а не просто vanilla JavaScript поради допълнителните функционалности, които предлага, които са изключително полезни по време на разработка на каквото и да е уеб приложение. Той позволява на разработчиците да декларират типове за променливи, параметри и функции, което подобрява надеждността и удобството на разработката, като предотвратява типични грешки в програмния код. 
Front-end уеб технологиите са важни инструменти за създаване на интересни и интерактивни уеб приложения/сайтове. 
Next.js е вид уеб технология, базирана на React (една от най-популярните JavaScript библиотеки), позволяваща създаването на бързи и надеждни уеб приложения.Тя, в основата си използва React, но също така предоставя и допълнителни функционалности, като изобразяване от страна на сървъра (Server-Side Rendering) и генериране на статични сайтове (Static Site Generation). Благодарение на тях, производителноста и оптимизацията за търсачки (SEO) на сайтовете са изключително подобрени. Тя също така разполага с доста голяма общност от програмисти, създаващи различни библиотеки и плъгини. Въпреки това, Next.js може да се окаже предизвикателство за новите потребители, заради нейната комплексност, и някои разработчици може да се чувстват претоварени от богатството на функционалностите ѝ.
Базираната на Svelte (популярен JavaScript framework) технология SvelteKit е съсредоточена върху разработването на невероятно ефективни уеб приложения. Тя се отличава с простота и е лесна за употреба. Разработчиците могат да създават ясен и четим код, благодарение на простия синтактис на Svelte. Технологията включва вградени преходи, анимации и други компоненти, подобряващи интерфейса. Обаче SvelteKit е все още сравнително нова технология, поради което тя има по-малко интеграции с други инструменти, библиотеки и плъгини.


Astro е друг вид технология, предназначена за създаване на бързи и гъвкави уеб приложения, с фокус върху съдържанието. Тя намира начин да смесва статично и динамично
съдържание подобрявайки скоростта на уебсайта и SEO-то. В резултат на нейните функционалности, които до голяма степен се препокриват с тези на Next.js и на факта, че използва различен метод за изобразяване на съдържанието (MPA, а не като другите- SPA), се постига отлична бързина и производителност, с почти нула клиентски (client-side) JavaScript. Освен това  позволява [c]на разработчиците да избират инструментите, които искат да използват, като HTML; CSS, Taiwind; JS, React, Svelte и др. Но все пак Astro страда от същият основен проблем, който присъства и в SvelteKit- че е доста нова технология, която не притежава толкова голяма група от отдадени програмисти все още.
Nuxt е уеб технология, изградена върху Vue.js, друг популярен JavaScript framework, за създаване  както на статични, така и динамични уеб сайтове[d]. Тя осигурява гладко изживяване за разработчици по време на създаване на сайт. Тази технология има лесен процес на настройка и голяма система с библиотеки и плъгини, които надграждат основните ѝ функционалности. Независимо от това, задълбочената употреба на технологията може да изисква по-добро и базисно разбиране на Vue.js и производителността може да пострада при много сложни и интерактивни страници. 
В крайна смета избрах да използвам Astro за моето уеб базирано приложение, тъй като смесва по много добър начин статичното с динамичното съдържание, което създава перфектният баланс за едно уеб приложение, което е едновременно доста интерактивно и динамично, и също така с много висока бързина и продуктивност. То също така ти дава свободата да си изградиш структурата и интерфейса на уебсайта, използвайки каквито технологии си пожелаеш, и не те “заключва” в използването само на определени технологии, като другите.
  



      2. Избор на технология за сървъра


Технологиите от страна на сървъра обхващат програмни езици и технологии, които обработват или изпълняват заявка на потребителя на сървъра, а не на устройството на клиента. Тъй като основният език за програмиране при уеб приложенията е JavaScript, и също така искам моето приложение да е изградено само с JavaScript (в частност TypeScript) като основен сървърен език за програмиране, то имам избор да използвам няколко популярни JavaScript сървърни технологии. 
Общото между тях е, че всички са пригодени да бъдат използвани в Node.js среда. Node.js се използва широко за програмиране от страна на сървъра, което дава възможност на разработчиците да използват JavaScript за код от страна на клиента и от страна на сървъра, без да е необходимо да учат допълнителен език.


Първата JavaScript сървърна технология е Express.js. Express.js, понякога наричан още „Express“ e Node.js back-end технология, която предоставя стабилни функции и инструменти за разработване на мащабируеми back-end приложения. Той ни дава система за маршрутизиране и опростени функции за разширяване на технологията, чрез разработване на по-мощни компоненти и части в зависимост от случаите на използване на нашето приложение. Тя предоставя набор от инструменти за уеб приложения, HTTP заявки и отговори, маршрутизиране и междинен софтуер (middleware) за изграждане на широкомащабни приложения. Също така тя поддържа различни машини за шаблони (template engines), което улеснява изобразяването на динамични HTML страници. Разработчиците могат да избират от различни популярни машини за шаблони, като EJS, Handlebars и Pug. Не на последно място, тя е проектирана да бъде мащабируема и може да обработва голям брой едновременни връзки. 
Едно от основните ограничения при използването на Express.js е, че той не предоставя строга структура или конвенция за организиране на кода. Въпреки че това може да бъде от полза за някои разработчици, които предпочитат гъвкавостта, то може също да доведе до объркан и труден за поддръжка код. Express.js [e]предоставя на разработчиците основен набор от функции за изграждане на уеб приложения, но той не включва много разширени функции извън кутията.
Следващата е Nest.js. Тя е прогресивна Node.js технология, която черпи вдъхновение от Angular и Spring и осигурява солидна основа за изграждане на мащабируеми и 
поддържани [f]приложения от страна на сървъра. Nest.js насърчава модулна архитектура, което улеснява организирането и управлението на кодовата база. Тя използва декоратори и модули за създаване на структурирано приложение и използва концепцията за инжектиране на зависимости, което позволява да създаваме многократно използвани и тествани компоненти. Това подобрява възможността за поддръжка и тестване на кода. Nest.js е проектирана с оглед на мащабируемостта, като поддържа архитектура на микросервизи, което го прави подходящ за големи и сложни приложения.

Но и тя си има своите слаби страни. Докато NestJS заимства архитектурни концепции от Angular, разработчиците без предишен опит в Angular може да открият, че кривата на обучение е стръмна и голяма. Възприемането на пълния потенциал на рамката и разбирането на нейните сложни характеристики може да изисква допълнително време и усилия. Въпреки че NestJS предоставя стабилни функции, някои разработчици може да са загрижени за потенциалните разходи за производителност в сравнение с по-леките рамки. Тази загриженост става уместна при изграждането на приложения с изключително висока производителност или микроуслуги, които изискват минимално потребление на ресурси. За приложения с малък мащаб модулната структура на NestJS и придържането към най-добрите практики могат да въведат ненужна сложност.


Друга подобна технология е Koa.js. Koa е сравнително нова сървърна технология, проектирана от екипа зад Express, която има за цел да бъде по-малка, по-изразителна и по-здрава основа за уеб приложения и API. Чрез използването на генератори Koa ти позволява да се откажем от обратните извиквания (callbacks) и значително да увеличим обработката на грешки. Koa не обединява междинен софтуер в ядрото и предоставя елегантен набор от методи, които правят сървърите за писане бързи и приятни. Тя е по-лека от другите Node.js рамки. Това помага при създаването на междинен софтуер, който е по-лек и по-ефективен.[g]
За разлика от Express.js, Koa.js не предоставя много вградени функционалности и модули за различни задачи. Това може да наложи използването на допълнителни модули или плъгини за някои функционалности. Поради своята минималистична природа, Koa.js може да не е подходящ за по-големи и по-сложни проекти, където са необходими по-мощни и готови за употреба функционалности.
Базирайки се на информацията за различните сървърни технологии, реших да използвам Express.js за моят уеб магазин. Избрах Express.js пред другите два фреймуърка, тъй като той предоставя балансиран подход между гъвкавост и функционалност. Express.js е популярен, широко използван и добре поддържан, като така осигурява стабилна и надеждна основа за разработка на уеб приложения. Освен това, Express.js предлага широк спектър от модули и плъгини, които могат да бъдат използвани за разширяване на функционалностите му, като така позволява създаването на разнообразни и гъвкави уеб приложения. 


      3. Избор на технология за базата данни


Базата данни представлява структурирана и организирана колекция от данни, позволяваща ефективно съхранение, извличане и управление на данни. Двете основни категории бази данни са SQL бази данни (релационни бази данни) и NoSQL бази данни (нерелационни бази данни). Съществуват много видове NoSQL бази данни, като някои от тях са: документни (document-oriented), ключ-стойност (key-value), графични (graph) и много други.


        MySQL е популярна система за управление на релационни бази данни (RDBMS) с отворен код (open source), [h]която управлява и променя данни с помощта на езика SQL. Тя организира данните в таблици с предварително дефинирани схеми, като осигурява цялостност и последователност на данните. Едно от основните ѝ предимства е спазването на ACID (Atomicity, Consistency, Isolation, Durability) модела за транзакции, което гарантира надеждни транзакции. MySQL е известна със своята стабилност, лекота на използване и широка използваемост в общността на разработчиците. Тя превъзхожда другите БД в приложения, изискващи сложни заявки и транзакции, като платформи за електронна търговия и финансови системи. Но въпреки това MySQL може да има проблеми с обработката на изключително големи масиви от данни. Осигуряването на пълно съответствие с ACID в разпределените системи може също да доведе до компромиси в производителността. 


        MongoDB е водеща NoSQL база данни, класифицирана като документално ориентирана, съхраняваща данни в JSON-подобен BSON формат. Тя е силно мащабируема и осигурява отлична поддръжка за хоризонтално мащабиране (scaling) чрез т.нар sharding (метод за разпределяне на данни между няколко машини). MongoDB е предпочитана за системи за
управление на съдържанието (content management systems), анализи в реално време и мобилни приложения, поради липсата на ясно определена схема за съхранение на данни, което го прави идеален за управление на полуструктурирани или неструктурирани данни. 
Въпреки това MongoDB има някои ограничения. За приложения, изискващи стриктното спазване на ACID модела, липсата на конвенционални ACID транзакции в MongoDB определено е недостатък. В сравнение с релационните бази данни, тя може да отнеме повече време за обработка на сложни заявки.


        Базата данни от типа ключ-стойност, с отворен код, съхраняваща данни ‘в паметта’ (‘in memory’) Redis е много известна със своята бързина и лекота на използване. За да осигури невероятно бързи операции за четене и запис на данни, тя записва данните като двойки ключ-стойност в паметта. Простотата на Redis е едно от основните ѝ предимства; тя се отличава с обработката на основни структури от данни като низове, хешове, списъци и други. Нейната функционалност да запазва данните в паметта гарантира минимално забавяне, което го прави идеален за използване при кеширане на данни и анализи в реално време. Обаче самата концепция на Redis, която е една от нейните най-силни страни, също така е една от най-големите ѝ недостатъци, а именно съхранението на данни в паметта.
Въз основа на информацията по-горе, реших да използвам MySQL за моето уеб базирано приложение/онлайн магазин, най-вече защото тя е  най-предпочитаната [i]база данни за използване в тази сфера-електронната търговия, поради възможността данните да бъдат съхранявани по предварително структуриран начин, и да изпълнява сложни заявки и транзакции. MySQL е известна със своята надеждност и съответствие с ACID модела за транзакции, което гарантира последователност и цялостност на данните, което е изключително важно за електронната търговия.


   5. Софтуерен дизайн


      2. Етапи на разработка


Има много стъпки, включени в процеса на разработка на уеб приложения. И количеството работа, извършена на всяка стъпка, зависи от обхвата на проекта. Нашата визия, бюджет, график, изисквания към персонала и технологични изисквания също играят фактор. Най-общо казано обаче процесът на разработка на уеб приложение включва следните основни стъпки:
1. Събиране на информация и поставяне на основни цели
2. Планиране
3. Дизайн на уеб приложение
4. Кодиране и програмиране
5. Копирайтинг и етикетиране
6. Тестване, преглед и стартиране
7. Поддръжка и актуализации след стартиране


1. Събиране на информация и поставяне на основни цели
Първата стъпка в проектирането на успешен уебсайт е да се събере цялата необходима информация. Много неща трябва да бъдат взети под внимание в този случай. Тази първа стъпка е всъщност най-важната, тъй като включва солидно разбиране за компанията, за която се работи. Предприемачите и фирмите най-вече започват с набор от идеи, когато мислят да стартират уеб приложение. Тези идеи бавно се развиват в подробен документ, в който са изброени целите на приложението, характеристиките, технологията, бюджетът, визията и бъдещите планове. Преминавайки през този документ, екипът за разработка получава ясно разбиране за целите на нашето приложение, ключови цели, целева аудитория, фокусна индустрия, етапи и други критични елементи. След като екипът за разработка на приложения има 100% яснота по всичко, свързано с проекта, предложението е подготвено, за да документира всичко, което ще бъде доставено.


2. Планиране


Използвайки информацията, събрана по време на първата фаза, е време да се състави план. Това е моментът, в който ще бъде разработена карта на сайта (sitemap). Картата на сайта представлява списък на всички основни тематични области, както и подтеми, ако има такива. Този план служи като ръководство за това какво съдържание ще бъде показвано и е от съществено значение за разработването на последователна и лесна за разбиране от всеки навигационна система. Крайните потребители на уебсайта (нашите клиенти) също трябва да се имат предвид при проектирането. Това в края на краищата са хората, които ще научат за нашата услуга или ще искат да си купят нашия продукт.
3. Дизайн на уеб приложение
Следващата стъпка е да усъвършенстваме дизайна и интерактивните елементи на нашето уеб приложение. Дизайнерът, следвайки договореният план, ще създаде различни макети (mockups), всеки със собствена уникална цветова схема, шрифт, графики, бутони, преходи и др. След финализиране на първоначалните макети, те се споделят с клиенти за преглед и обратна връзка. Итерациите на дизайна и промените в макета продължават, докато клиентът не одобри всичко. Докато дизайнерският екип е зает с макети и усъвършенстване, екипът за разработка е ангажиран предимно с програмната част. Така че тези два етапа обикновено се движат един до друг.
4. Кодиране и програмиране
В този етап уебсайтът практически се създава. По това време дизайнерът ще вземе всички отделни графични елементи от различните макети и ще ги използва, за да създаде действителен, функционален сайт. Това обикновено се прави, като първо се създаде началната страница. Елементи като система за управление на съдържанието (CMS), интерактивни формуляри за контакт или платформа за онлайн продажби се изпълняват и стават функционални и по време на тази фаза. Front-end разработката е използването на различни уеб технологии, като HTML, CSS и JavaScript, за изграждане на частите от уеб приложението, които потребителят може да вижда и да взаимодейства с тях. Междувременно back-end разработката означава работа върху сървърния софтуер, който се фокусира върху всичко, което потребителят не може да види, като бази данни, back-end логика, интерфейси за програмиране на приложения (API) и архитектура. Оптимизацията за търсачки (SEO) може също да се проведе в този етап.
5. Копирайтинг и етикетиране
Копирането и етикетирането са по-малко от 5% от работата по разработката на приложения, но без тях е трудно да разберете всичко, което сме изградили.  Потребителското изживяване и потребителският интерфейс до голяма степен зависят от таланта на информационния архитект и копирайтъра, ангажирани за проекта. Използваемостта и простотата трябва да бъдат епицентърът на тази стъпка в процеса на разработка на уеб приложения. Този етап е за финализиране на заглавия, надписи, етикетиране, копие и всичко останало, което е в текстовата форма. 
6. Тестване, преглед и стартиране
Тестването е една от най-важните стъпки в процеса на разработка на уеб приложения. То потвърждава, че уеб приложението работи по предназначение и отговаря на всички съответни организационни, индустриални и глобални стандарти. То обикновено се извършва от специален екип за осигуряване на качеството (QA). Те извършват комбинация от ръчно и автоматизирано тестване за откриване на бъгове, грешки, сривове и други проблеми.  Като част от тестването, този екип трябва да провери валидността на всички кодове. Валидният код означава, че сайтът ни отговаря на текущите стандарти за уеб програмиране – това е от полза при проверката на функции като съвместимостта с различни браузъри. Също така те ще тестват практически всеки аспект на софтуера, включително качеството на потребителското изживяване, нивото на сигурност, производителността, функционалността и отзивчивостта (responsive design-а).
7. Поддръжка и актуализации след стартиране


Един от начините да привличате постоянен поток от посетители на сайта ни е редовно да им предоставяте ново съдържание или продукти. Независимо дали става въпрос за обикновен бизнес уебсайт или сложно уеб приложение, всеки дигитален продукт се нуждае от рутинна поддръжка, проверка и подобрения. С течение на времето можем да искаме да предприемем продуктови центрове, да интегрирате нови функции и да стартирате версия 2 на приложението. Ето защо нашето споразумение за разработка на приложение трябва да говори за поддръжка на приложението, поддръжка след доставката и бъдещи надстройки.
      3. Софтуерна архитектура [j]


Model-View-Controller, или т.нар. MVC е архитектурен шаблон за проектиране на софтуер, който се използва[k] за създаване на интерактивни и динамични потребителски интерфейси. За пръв път норвежкият компютърен учен Тригве Реенскауг популяризира концепцията за MVC в края на 70-те години на XXв., докато работи по Smalltalk-80, (обектно-ориентиран език за програмиране, създаден в Xerox PARC). Накратко MVC моделът разделя приложението на три взаимосвързани части, всяка от които има отделна роля:


1.Модел (Model)- Моделът представлява данните и основната бизнес логика на приложението. Той е отговорен за управлението и обработката на данните, въведени от 
потребителя и приемането на заявки от изгледа (View) и контролера (Controller). Моделът уведомява изгледа и контролера, когато има промяна в данните, като гарантира, че те винаги са синхронизирани помежду си. Моделът е независим както от изгледа, така и от контролера, което означава, че промените в потребителския интерфейс или методите за въвеждане на данни от потребителя не засягат основната логика за обработка на данни. 


2.Изглед (View)- В MVC изгледът е отговорен за представянето на компонентите на потребителския интерфейс и показването на данните от модела на потребителя. Той получава данни от модела и ги подготвя за представяне. Всяко изходно представяне на информация, независимо дали е уеб страница/приложение, диаграма или схема, може да се счита за изглед. Изгледът не управлява бизнес логиката или обработката на входните данни на потребителя, а по-скоро само показва данните и компонентите на потребителския интерфейс. 


3.Контролер (Controller)- Контролерът служи като посредник между изгледа и модела. Той приема входни данни от потребителя, обработва ги (обикновено чрез извикване на методи на модела) и след това опреснява изгледа с резултатите. Контролерите обработват действията на потребителите, манипулират данните в модела и определят кой изглед да се покаже. Той гарантира, че изгледът и моделът никога не комуникират директно, а всички взаимодействия се осъществяват чрез него. Контролерът също обработва събития, задействани от потребителя, като щраквания върху бутони или въвеждане от клавиатурата, и решава как приложението да реагира на тези събития, осигурявайки безпроблемно потребителско изживяване. 


Модулността (Modularity) на архитектурата MVC е едно от основните ѝ предимства. Разделянето на отговорностите на отделни елементи (Model, View и Controller) улеснява поддръжката и разширяването. Програмата е по-управляема, когато разработчиците могат да работят поотделно върху различни нейни части, особено при големи и сложни проекти. Друго предимство е многократната употреба. Тъй като компонентите са разделени, един и същ модел може да се използва с различни изгледи или обратното, подобрявайки гъвкавостта. Тази възможност за повторна употреба насърчава ефективността на кода и спестява време за разработка в дългосрочен план.
MVC моделът обаче не е лишен от своите недостатъци. Свръхсложността е една от основните пречки. Внедряването на цялостния MVC модел в по-малки приложения може да добави ненужна сложност, което ще направи кода по-труден за четене и поддръжка. 


Друг проблем възниква със синхронизацията. Тъй като компонентите са взаимозависими, осигуряването на правилна синхронизация между модела, изгледа и контролера може да бъде предизвикателство. Несъответствия в данните или състоянието могат да възникнат, ако не се управляват правилно, което води до неочаквано поведение в приложението. Освен това, кривата на обучение на MVC модела е сравнително голямо, особено за начинаещште разработчици.


      4. Описание и взаимодействие с приложението[l]


Интеракцията на всички видове потребители (регистрирани и нерегистрирани / гости) с моят онлайн магазин може да се види схематично на Фиг. 2.2.3.1.
  



        Както можем да забележим, потребителите могат да взаимодействат с много и различни части от това уеб приложение. Първото, което трябва да направят, е да посетят уебсайта, което може да стане чрез въвеждане на URL адреса на сайта или щракване върху линк, препращащ към него. Следващите две стъпки не са задължителни и могат да бъдат направени по всяко време от клиента, без значение в коя част на уеб приложението се намира той. Първата такава стъпка дава възможност на потребителите да избират различни:
* цветови тематики (гами)- Уебсайтът поддържа няколко основни цветови гами, състоящи се най-вече от един основен цвят, последван от поредица нюанси на този конкретен цвят, включително по-светли и по-тъмни. Цветовата гама по подразбиране е червена, но потребителят може да избере да използва и някои от останалите, а [m]именно зелена, синя, лилава или розова. Той също така използва за фон белият цвят, а за текст- черният, което създава ясен контраст, с цел по-добра четимост и яснота на предоставената информация.


* езици- Тъй като таргетираната аудитория за това уеб приложение е интернационална, то и самото приложение трябва да бъде интернационално, и да предлага на своите потребители да изберат на какъв език искат да им бъде уебсайта. Когато клиента 
избере предпочитания език, уеб приложението автоматично превежда цялостното си съдържание, благодарение на интеграция с приложение от трети страни( в този случай API на преводачката Deepl). Това автоматично и почти мигновено превеждане на информацията елиминира нуждата от създаване на изцяло друга версия на същия онлайн магазин, с разликата че неговото съдържание [n]е на друг език и е хостнат на друг URL, обикновено включващ съответният език, като www.random.com/language-en . Но от друга страна, тъй като автоматичният превод, поддържан от различните онлайн преводачки, е не винаги на 100% коректен, в сравнително редки случаи е възможно да се създаде неточност и неяснота на информацията, което естествено не е добре за имиджа на нашето уеб приложение. В момента поддържаните езици са английски и български. 


   * валути- Поради същата причина, която споменах за езиците, потребителите трябва да имат възможност да избират валутата, в която искат да разглеждат продуктите, и в която ще плащат своите поръчки. В момента поддържаните валути са долар, лев и евро, като курсът на валутния обмен между тези валути е строго кодиран в рамките на приложението и отразява текущият по време на кодирането валутен курс. 


Следващата незадължителна стъпка е възможността за комуникация със специализиран customer support чатбот. Потребителите могат да задават всякакви въпроси, свързани с компанията Technoworld, с продуктите, които продава тя, включително задълбочена информация за всеки един от тях, с различните политики, които тя спазва и т.н. и той ще им даде точен и изчерпателен отговор, задоволяващ тяхната нужда от 


информираност по дадената тема. Той също така може да бъде от полза на клиента и в много други сценарии, като например за сравнение на продукти и обобщаване на това кой е най-добрия продукт за определена цена, за по-лесно и просто навигиране между различните страници и компоненти в уебсайта и др. 


По някое време потребителят трябва да вземе решението дали да се регистрира в уеб приложението, или да продължи да го използва като гост. Ако иска да продължи като гост, той ще разполага с лимитирана функционалност, включваща предните две функционалности плюс възможността да разглежда, търси, филтрира и сортира продуктите по определени базови критерии, като ключови думи, спецификации, цена и др. Ако пък се регистрира, като въведе своят username, e-mail адрес и сигурна парола, която е най-малко 6 символа и съдържа комбинация от главни и малки букви и цифри(или влезе в профила си, ако вече има такъв) ,той ще отключи цялостната предвидена функционалност на уебсайта.


След като се е регистрирал, клиентът може да взаимодейства с приложението напълно, като може да извършва следните дейности в какъвто ред иска и пожелае:


   * Наддава за цената на специални продукти- Потребителят може да използва и да се наслади на тази уникална за онлайн магазин функционалност. При нея администраторът избира специални и лимитирани продукти, за които клиентите да наддават, като те въвеждат сумата, която са готови да платят за продукта. Важно е да се уточни, че за всеки един продукт има предварително зададена минималн цена за наддаване, и също така след всяко следващо наддаване, минималната цена за наддаване се увеличава с определен процент (между 5% и 20%). Всяка седмица каталогът с продукти за наддаване се актуализира с 4 нови попълнения, а 4-те предишни продукта се премахват от тази секция. Накрая, когато времето за наддаване за цената на даден продукт свърши, или цената за наддаване е достигнала изкупната цена на продукта, потребителят с най-високата оферта печели съответния продукт.


   * Оценява продукти- Всеки регистриран потребител има възможността да оцени даден продукт с рейтинг от 1 до 5 (като 1 е най-негативно, а 5 е най-позитивно) и да остави коментар (незадължително), в който да обоснове защо така е оценил този продукт. 
   * Тази функционалност определено би помогнала на хората да вземат по-информирани решения за това кой продукт да си вземат, тъй като чрез това оценяване, те ще могат да преценят дали този продукт е добър, качествен и надежден, или е некачествен и не става за нищо.


   * Добавя продукти в любими- Следващата функционалност позволява на потребителя да добавя продукти, които харесва, намира за интересни или са му направили някакво положително впечатление, в секцията любими. Така той има бърз, лесен и удобен достъп до тях и може с един клик да ги добави в своята количка, или да ги изтрие от тази секция, ако пожелае.


   * Добавя продукти в количка- Клиентът може и директно да добави продукт в количка, без да е нужно първо да го добавя в любими. Количката е функционалност, която позволява на потребителите да избират продукти, които искат да купят, и да продължат към процеса на плащане.


   * Създава и преглежда поръчки- След като потребителят е избрал продуктите, които иска да си купи, той започва процеса по създаване на поръчка. Първата част от този процес е да попълни информация за мястото, до което ще му бъдат доставени продуктите, като трябва да посочи град, точен адрес, пощенски код и др. След като submit-не тази информация, започва втората част, която включва въвеждането на информация за плащането, като трите имена, с какво ще плати (кредитна карта или Paypal), номер на кредитната карта и т.н. Тази част от създаването на поръчка е изцяло изградена с помощта на интеграцията за плащания Stripe, която цялостния процес на плащане лесен и удобен както за крайния потребител, така и за разработчика на уебсайта. След като потребителят подаде нужната адресна и разплащателна информация, поръчката се обработва от уеб приложението и почти веднага се праща емайл на клиента, в който се посочват статистики, като статус на поръчката, обща цена на поръчката, поръчани продукти и др. 


   * Други дейности с профила си- Освен горепосочените начини на взаймодействие между потребителя и уебсайта, той може също така да извършва и други дейности в уеб приложението, свързани с профила си, като да го актуализира,  да излиза от него или направо да го изтрие напълно и безвъзвратно. 
Взаимодействието на администратора с приложението обаче е малко по-различно от това на останалите потребители. Освен че той може да извършва всички горепосочени функционалности, той също така има достъп до специалния администраторски dashboard, намиращ се в секция Account, чрез който той може да: преглежда информация за всички потребители (като id-та, потребителски имена и имейли), да изтрива акаунта на даден потребител (в случай че той е извършил някакво нарушение спрямо наложените правила);
преглежда информация за всички направени поръчки (като id-та, име на клиента, обща цена, и др), актуализира статуса на дадена поръчка; прежлежда информация за всички налични продукти (като снимка, име, категория, цена и т.н.), създава, редактира или изтрива определен продукт; разглежда информация за всички търгове (като име, начално и крайно време, най-висока оферта и др.), създава, редактира или изтрива даден търг.


   5. Графичен дизайн и структура на приложението[o]


Нека първо започнем с графичния, и по-конкретно цветовия дизайн на уеб приложението. Както вече споменах, уебсайта предлага различни цветови гами, които потребителя може да избере, на база на своя собствен вкус и преференция. Позволяването на потребителите да избират предпочитаната от тях цветова гама им дава усещане за персонализиране. Той позволява на потребителите да приспособят външния вид на уебсайта към своите индивидуални предпочитания, което може да подобри цялостното им изживяване спрямо приложението. Освен това различните цветови схеми могат да предизвикат различни настроения или естетика. Като предоставя селекция от различни цветови гами, уебсайтът може да се погрижи за по-широка гама от вкусове и предпочитания.
  

На тази фигура можем да видим част от графичния дизайн на уеб приложението. В този случай тя ни показва как изглежда лилавата цветова гама, начинът по който продуктите са визуализирани, структурирани и стилизирани в стил на отделни карти(card-ове), част от страницата за търсене на продукти и също и лентата с менюта(Navbar). Тя е достъпна на всички страници в приложението и служи като средство за навигация, осигурявайки лесен достъп до различните раздели на уебсайта. Тя е важна, защото помага на клиентите да намират лесно това, от което се нуждаят. Фактът, че лентата с менюта остава същата на всяка страница, показва, че уебсайтът обръща внимание на малките детайли. Navbar-ът играе критична роля в приложението, като осигурява организирано и удобно за използване преживяване за потребителите. 


Сега ще преминем към структурния аспект на уеб приложението, или с други думи казано, с помощта на какви уеб страници е изграден и структуриран той. За да може един уеб магазин като този да функционира както трябва, а именно правилно, качествено и ефективно, е необходимо то да бъде изградено от множество уеб страници. Ето от какви основни уеб страници е изграден моят уебсайт:


   * Начална страница (Home / Landing Page)- Може да се види на фигура 5.1 от секцията Приложение. Това е първата и основна страница на уебсайта[p], показваща се всеки път когато потребителя влезе в уеб приложението или навигира от други страници на приложението към началната. Страницата е изградена от различни компоненти, като картички, рекламиращи някои от наличните категории, Hero секция / Slider, препоръчани нови продукти и рекламен материал, промотиращ функционалността за наддаване за на специални продукти.


   * Страница за регистрация (Registration Page)- Чрез тази страница потребителите могат да създатат нов профил, да влязат във вече съществуващ профил, или да използват своят Google профил, и чрез него да се регистрират в уебсайта(като тук е използвана third-party интеграция с Google). 


   * Страница за акаунта (Account Page)- Част от тази страница е представена на фигура 5.6 и в нея потребителите могат да видят информация за своят профил, като username, first name, last name, телефон и парола, която могат да редактират по всяко време.
Освен това те могат да виждат информиация за направените от тях поръчки, като дата и час, обща сума, брой артукили и статус на поръчката. За администратора тази страница предоставя доста повече функционалност, тъй като в нея се намира и администраторския панел(admin dashboard-a), за който вече споменах по-горе. 


   * Страница за търсене на продукти (Search Page)- Тази страница може да се види на фигура 2.2.4.1. от текущата секция. Тя позволява на потребителите да търсят продукти по ключови думи, име или част от спецификацията на дадения продукт; филтират продуктите по категории, цена, брандове, спецификации и рейтинг; и да сортират продуктите по различни критерии, като рейтинг(от най-висок към най-нисък или обратното), име(от A до Z или обратното) или цена( нисходящо или възходящо)


   * Страница за конкретен продукт (Product Page)- Страницата е представена на фигура 5.2 от Приложението, и в нея потребителите могат да разгледат цялата налична информация за конкретния продукт, като име, цена, детайлно описание и др. Освен това, те могат да оценят съответният продукт и също така им се предлага секция сходни продукти, където се показват сходни на разглеждания продукт артикули(например ако разглеждаме телефон, тази секция показва други сходни телефони)


   * Страница за търгове на специални продукти(Auctions Page)- Може да се види на фигура 5.4. и, чрез тази страница, потребителите отключват възможността да участват в различни интригуващи търгове на лимитирани продукти, като наддават за тяхната цена. Тя се актуализира всяка седмица, като се добавят нови 4 търга, а предишните 4 се изтриват. Също така всяко наддаване се случва в реално време(благодарение на Node.js package-a Socket.io), като по този начин потребителите могат да виждат офертите, предложени от други потребители за дадения търг, почти веднага след като бъдат направени, което гарантира мигновенен достъп до най-новата и актуализирана важна информация. 


   * Страница за конкретен търг (Auction Page)- Част от страницата на конкретен търг е представена на фигура 5.5. от секцията Приложение. В тази страница потребителите могат да видят снимки на продукта, върху който е изграден съответният търг, заглавието и описанието на дадения търг и също така да участват в него, ако той не е свършил (отбелязан с тага exprired) или затворил (отбелязан с тага closed) . Освен това
   * тази страница съдържа и цялата история на наддаванията, която показва броя на направените оферти, кой потребител е наддал за този търг, каква сума е предложил той и кога е направена тази оферта. Това е направено с цел потребителите да бъдат колкото се може по-информирани за съотвеният търг.


   * Страница за любими продукти (Wishlist Page)- Може да се види на фигура 5.3. В тази уеб страница се визуализират продуктите, които клиентът е добавил като любими. Оттук клиента може да добави някой продукт в количката, или да го изтрие от любими.
   * Страница за кошница (Cart Page)-  В тази уеб страница се визуализират продуктите, които клиентът е добавил в своята количка. Оттук клиента може да изтрие някой продукт от количката, или да продължи към следващата страница.


   * Страница за плащане (Checkout Page)- Тук потребителя въвежда информация, свързана с процеса на създаване на неговата поръчка, като адрес на доставка, информация за неговата кредитна карта или PayPal акаунт, и накрая, след като поръчката е създадена успешно, потребителят е пренасочен пак към началната страница.


   * Допълнителни страници- Уебсайта също така разполага и с допълнителни страници, свързани най-вече с различните политики, които следва, като политика на бисквитите, условия за ползване, политика за поверителност, политика за връщания / замяна на продукти, свържете се с нас, нашите услуги, често задавани въпроси и други.


   6. Дизайн на сървъра[q]


Сървърът е главно изграден върху Node.js, Express.js и Astro. Но как така, Astro. Тя не е ли уеб технология за работа само клиентската част (client-side). Да, но не съвсем. Astro притежава т.нар. Server Endpoints (API Routes) функционалност, при която ако приложението ти, както в случая е това, е рендерирано от страна на сървъра(server-side rendered), Astro позволява изграждане и ескпортиране на API маршрути (routes), които слушат за HTTP заявки, като GET, POST, PUT, DELETE и др, и сигурно изпълняват код на сървъра по време на изпълнение. Тази концепция на Astro е идентична на Express.js routing-a, в който по същият начин може да създаваме и ескпортираме различни API маршрути, които да слушат за различните HTTP заявки.
Освен това при server-side рендерираните приложения, всички страници се генерират на подаден GET request на протребителя за тази съответна страница, а не по време на изграждане на сървъра (server build time), както е при статично генерираните приложения. Например при първоначално влизане на потребителя в нашия уебсайт, той изпраща GET request към сървъра и сървъра генерира необходимият HTML и CSS код за създаването на началната страница и го изпраща на клиента, където после тази страница се визуализира.  
На тази фигура е представен дизайна и структурата на главния Node.js сървър. От нея можем да видим, че използвам Express.js, няколко различни Node package-a, като middleware на Express: compression за компресиране на response информацията, получена от request-a, cors за Cross Origin Resourse Sharing, и Socket.io за събития, които се случват и актуализират в реално време, като наддаването, и вградените в Node модули, като fs и https. За да може сървърът да работи на https, най-лесният и прост начин e да използваме self hosted ssl сертификат за тази цел. Тъй като всички API rout-ове на това приложение сa конфигурирани от Astro, то трябва да импортираме и да използваме като middeware handler функцията. Тя автоматично се създава и експортира от Astro всеки път когато сървърът се изгражда (build-ва), и в нея се съдържа цялата функционалност, свързана с изграждането и работата на API rout-овете, и като цяло на целия Astro сървър, който впоследствие се “слепва” за основния Node.js сървър, като Express middleware. 
Също така можем да конфигурираме много неща, свързани с този Astro сървър, като конфигурациите се съхраняват в astro.config.mjs файл. Част от тях включват: 
   * Адаптер (Adapter)- специален вид интеграция, която се използва за изпълнение на нашия проект на определена сървърна среда- като Node, Deno, Vercel и др. Можем да зададем и режимът, към който се изгражда адаптера, като има два оссновни вида
   * 'middleware' – Създаване на мидълуер, който да се използва в рамките на друг Node.js сървър, като Express.
   * standalone' - Създаване на самостоятелен сървър. Сървърът стартира само чрез стартиране на изградения скрипт.
   * Изход (Output)- Указва изходната цел за компилации, като имаме три основни вида
   * 'статичен' - Изграждане на статичен сайт, който да бъде разположен на всеки статичен хост.
   * 'сървър' - Изграждане на приложение, което да бъде deploy-нато на хост, поддържащ SSR.
   * 'хибрид' – Изграждане на статичен сайт с няколко изобразени страници от страна на сървъра.
   * Предварително извличане (prefetch)- Активира предварително извличане на връзки на сайта, за да осигури по-бързи преходи между страниците.
   * Интеграции- Това са като Node пакетите, само че се използват в рамките на Astro сървъра, като за моето приложение използвам compress, което компресира файлове, и  tunnel, който ми позволява да изложа локалния dev сървър в интернет пространството. 
  
[r]
   7. Дизайн на базата данни[s]


Важно уточнение!- Всички таблици съдържат колоната createdAt, която указва времето, в което е създаден даден запис в дадена таблица, и в почти всички присъства колоната updatedAt, която показва кога точно се е актуализирал даден запис в дадена таблица. Тези две колони са от тип DATETIME и биват автоматично добавени от Sequelize (Object Relation Mapper-а, който е използван в това приложение) с изграждането на всяка таблица, като те могат да бъдат премахвани и обратно добавяни  по всяко време, когато пожелаем.   [t]
Първо имаме таблицата users, където се съхранява информация за всички регистрирани потребители на приложението. Тя се състои от следните колони: 
- uuid (Universally unique identifier)- случайно генерирана 128 битова string стойност, играеща роля на първичен ключ на таблицата от тип CHAR (36)
- username- Съхранява създадения от потребителя username, типът на данните е varchar (45), тъй като дължината на username-овете може да варира
- email_addres- Съхранява зададения имейл адрес, като типът на данните е varchar (45)
- password- Запазва хешираната парола на потребителя (за тази цел е използвана библиотеката bcrypt), като типът е varchar (45) по същата причина, като предишните.
        - role- Определя ролята на потребителите (дали те са user-и или admin-и), като това става в момента на регистрация на потребителя; типът е varchar (10)
- first_name- Запазва първото име на потребителите (незадължително ако вече има username, но задължително се извлича от Google профила му, ако се регистрира чрез своя Google акаунт) и е от тип varchar (45)
- last_name- Същото като first_name, само че се използва за фамилното име
- phone_number- Показва телефона на потребителя, като той е от тип char (10), тъй като мобилните номера в България са точно 10 цифри
- gender- Предоставя избор на потребителя да избере своят пол (незадължително), като това се случва от dropdown меню и типът на съхранените данни е varchar (8)- is_subscribed_to_newsletter- Показва дали потребителят се е абонирал за newsletter-а   на уебсайта (да или не) и типът му е boolean, точно за тази цел


След това следва таблицата chatbot_messages, която има следните полета:
message_uuid- uuid-то на всяко изпратено съобщение (PK) от тип char (36)
   * user_uuid- uuid-то на потребителя, който си комуникира с чатбота и е от тип char (36), защото е foreign key, свързващ тази таблица с users;
   * is_user_message- Типът на данни е boolean и показва дали изпратеното съобщение е от потребител (true), или от чатбота (false)
   * message_content- Представлява самото съобщение, като типът му е mediumtext (може да съхранява до 64MB данни), тъй като може да има и много дълги съобщение.


Таблицата shopping_cart_items съдържа тези колони:
   * cart_item_uuid- uuid-то на всеки добавен продукт (PK) с тип char (36)
   * user_uuid- uuid-то на потребителя, добавил съответният продукт в количка (FK) с тип char (36)
   * product_uuid- uuid-то на съответния продукт, добавен в количката (FK) с тип char (36)
   * product_quantity- количеството на всеки един добавен продут от тип integer
   * total-price- общата цена на всички добавени продукти и е от тип integer.


Следващата таблица е orders и тя съдържа следните полета: 
   * order_uuid- uuid-то на всяка направена поръчка (PK) и е от тип char (36)
   * user_uuid- потребителя, направил съответната поръчка (FK) от тип char (36)
   * ship_address_uuid- адреса за доставка на съответния потребител (FK) с тип char (36)
   * order-items- броят на поръчаните продукти и е от тип integer.
   * total_price_amount- общата цена на поръчката също от тип integer.
   * order_status- показва текущия статус на поръчката и типът на данните е varchar (20)
   * payment_status- показва статуса на плащането и е от същия тип като предишното


Таблицата shipping_addresses съдържа следните колони в себе си:
   * ship_address_uuid- uuid-то на всеки създаден адрес (PK) и е от тип char (36)
   * user_uuid- потребителя, създал съответният адрес на доставка (FK) от тип char (36)
   * address- съхранява въведения от потребителя адрес (улица, блок, вход и т.н.), а типът на данните е varchar (80)
   * city, state, postal_code и country- Запазва съответно града, щата (или пак града ако сме извън USA), пощенския код и страната; всички са от тип varchar(), съответно varchar (25), varchar (45), varchar (8) и varchar (45)


В таблицата wishlist_items се съдържат следните малко на брой полета:
- wishlist_item_uuid-uuid-то на всеки добавен продукт в любими (PK) от тип char (36)
- user_uuid- потребителя, добавил съответния продукт (FK) и е от тип char (36)
- product_uuid- съответния продукт, добавен в любими (FK) от тип char (36)


Таблицата auction е по-голяма и съдържа повече колони, като те са съответно:
- auction_uuid- uuid-то на всеки създаден аукцион (PK) от тип char (36)
- name- съхранява името на аукциона и типът на данни е varchar (150)
- description- описание на аукциона и на продукта, върху който се наддава; типът на данни е mediumtext, тъй като описанията могат да бъдат изключително дълги
- product_uuid- продукта, за който се наддава в съответния аукцион (FK) и е от тип char (36)
- initial_price- първоначалната цена на аукциона от тип integer
- minimum_bid_increment_percentage- представлява процентът, с който се увеличава минималната сума на офертата в търг. Използва се за изчисляване на минималната сума на офертата, като се гарантира, че следващите оферти надвишават предишната най-висока оферта с определения процент.
- start_time и end_time- показват времето, като са тип datetime, в което търгът започва и съответно свършва
- purchase_price- изкупната цена на определения продукт, върху който е изграден дадения търг. Ако по време на търг се достигне тази цена, то автоматично потребителят, който е предложил оферта равна на изкупната цена + 1 печели търга. Тя е от тип integer.
- bid_counter- следи броя на вече направените оферти на даден търг и е от тип integer,- current_highest_bid и current_highest_bidder- информация съответно за най-високата направена оферта и uuid-то на човека, направил тази оферта (FK), в рамките на даден търг. Те са от тип както следва: double (6,2) и char (36);
- bid_history- съхранява информацията за всички направени оферти за даден търг. Тя е от тип JSON, тъй като съхраняваната в нея информация е във JSON формат, в който съдържа следната информация: направената оферта, потребителското име на клиента, направил тази оферта, и времето, от тип datetime, в което е направена офертата.


Предпоследната таблица, а именно products, разполага със следните полета:
- uuid- uuid-то на всеки наличен продукт (PK) и е от тип char (36)
- image_src, image_src_2 и image_src_3- запазват url-а на трите снимки, използвани за рекламиране на продуктите. Типът им е mediumtext, тъй като при създаването на продукт и посочването на 3 url-а, на който са хостнати тези снимки, се извършва обработка на снимките, която включва тяхното fetch-ване и преобразуване от всякакъв тип (png, jpg, webp) към avif във формат-`data:image/avif;base64,${img_src}`
- name- името на продукта от тип varchar (250), тъй като в него се съдържат всички негови значими характеристики
- description- детайлно описание на продукта и неговите спецификации и е от тип mediumtext
- price- цената на съответния продукт от тип integer
- average_rating- средно аритметичното на всички направени оценки на продукта (от 1 до 5 звезди) и е от тип double (2,1)
- quantity и category- съхраняват съответно наличното количество на продукта и неговата категория, като те са от тип integer и varchar (45) респективно
- advertisable и biddable- това са два флага, от тип boolean, които показват дали дадения продукт да бъде показан на началната страница като рекларируем 
и дали той може да участва в търг. Ако biddable е true (т.е. продуктът вече може да се използва за изграждане на търг около него), то този продукт вече не е част от другите продукти и не можеш да го купиш и намериш никъде, освен в секцията за търгове.


Последната от тези 9 таблици е product_reviews и тя е изградена от следните полета: 
   * review_uuid- uuid-то на всяка направена оценка на продукта (PK) от тип char (36)
   * user_uuid и product_uuid- съответно потребителят, публикувал този рейтинг (FK) и продуктът, към който се отнася той (FK). Те са от тип char (36)
   * rating- самата оценка на продукта и е от тип integer
   * review_text- писмен коментар, отразяващ мнението на потребителя спрямо дадения продукт(незадалжително за попълване), от тип mediumtext.


Следва връзките между таблиците, които са общо 12 на брой. 
Разбираемо, с най-много връзки е таблицата users, която има цели 7 връзки. Първата нейна връзка е с таблицата chatbot_messages. Типът ѝ е едно към много, тъй като един потребител може да изпраща повече от едно съобщение на чатбота (например 2,3 или повече). Следващата връзка е с shopping_cart_items, като тя е от тип едно към много. Това е така, защото един клиент може да има повече от един продукт добавен в своята количка. След това имаме връзката с таблицата wishlist_items, която като предишната е от тип едно към много, поради същата причина.


После имаме връзка с auctions, която е едно към много, защото един потребител може да участва в повече от един търг. Следващата връзка е с product_reviews, която е от тип едно към много, тъй като един клиент може да създаде повече от едно ревю на един и същ или на различни продукти. Предпоследната връзка е с shipping_addresses, която е от тип едно към едно, тъй като един потребител може да има само и единствено един адрес за доставка, който може да се редактира при нужда. И накрая имаме връзката с orders, която пак е едно към много, поради причината, че един човек може да направи повече от една поръчка.


Следващата таблица с най-много връзки (4 на брой) е products. Първата ѝ връзка е с таблицата shopping_cart_items. Типът на връзката е едно към много, тъй като един продукт може да бъде добавян повече от един път в количката на даден потребител. Следващата връзка е с wishlist_items, като тук връзката е едно към едно. Това е така, защото един продукт може
да бъде добавян точно един път в списъка с любими продукти. Освен това има връзка с таблицата auction, като тя е едно към едно, защото един продукт може да участва само в един единствен търг. Последната връзка е с product_reviews. Тя е от тип едно към много, защото един продукт може да има повече от едно ревю.
И на последно място има още 1 връзка между таблиците shipping_addresses и orders. Тя е от тип едно към много, тъй като на един адрес на доставка могат да бъдат доставени повече от една поръчка.


   8. CRUD заявки


Eто примери за това как могат да се извършват CRUD заявки с помощта на Astro Server Endpoints и Sequelize:
  

Както можем да видим, Create заявката е доста лесна и проста. Първо импортираме създадения от нас Product клас. Той e абстракция на таблицата Product и представлява клас, който наследява класа Model, идващ от Sequalize. В него дефинираме какви полета има този клас (трябва да същите като таблицата), след това инициализираме класа, представляващ таблицата в DB, със вече дефинираните полета и съответните опции към тях и накрая го експортираме, за да можем да го използваме където искаме. 
Има много и различни опции, като някои от тях са: 
   * type- указва типът на данните, като UUID, STRING, NUMBER и т.н.
   * primaryKey- флаг, показващ дали дадено поле е първичен ключ
   * allowNull- флаг, който показва дали дадена колона от таблицата може да приеме NULL стойности
   * references- обект, който се използва за изграждане на връзка между таблиците. Той съдържа моделът (класът), към който ще правим връзка и неговия PK
   * defaultValue- указва каква стойност и от какъв тип да е стойността по подразбиране;  
За Create заявката първо взимаме данните за продукта, предоставени от front-end-а, след това извикваме create метода на Product класа, който е наследен от базовия Model клас, който създава този продукт с тези характеристики в базата данни и накрая изпращаме продукта и неговите данни обратно към front-end-a, за да може да бъде достъпван и използван от клиентската част, ако се налага.
  

Във фигурата по-горе е представен пример за Read заявка, която също е доста лесна за имплементация. От клиентската част получаваме uuid-то на даден продукт от params
параметъра и го използваме в where клаузата на метода findOne, който намира един единствен продукт, в случая по полето uuid, което съответства с полученото uuid. Накрая изпращаме получения продукт към клиента, за да може да се визуализира при заявка.  
Тук е показана Update заявката за актуализиране на характеристиките на един продукт. От клиентската част получаваме uuid-то на продукта отново от params параметъра и актуализираните характеристики от тялото (body-то) на направения PUT request. След това намираме този продукт чрез полученото uuid, и актуализираме тези полета, които са подадени от front-end-а, а тези, които не са, си остават без промяна и накрая изпращаме към клиента съобщение. 
  

Накрая имаме Delete заявката, която показва как се изтрива един продукт от базата данни. Първо получаваме неговото uuid от клиента и след това извикваме метода destroy, който
премахва този запис от базата данни. Ако премахването е успешно, не пращаме нищо, но ако има проблем, изпращаме съобщение, че има някаква грешка.


      6. Тестване


Върху приложението е проведено обширно тестване с цел осигуряване на неговата функционалност и надежност. За тази цел са използвани различни методи за тестване, които включват тестване на интеграцията, системата, "бялата кутия" и "черната кутия". 
Тестването на интеграцията е проведено с цел да се покаже, че всички компоненти на приложението работят съгласувано и безпроблемно един с друг. Това включва проверка на взаимодействието между различните модули, услуги и данни, които приложението използва. 
Тестването на "бялата кутия" се базира на анализ на вътрешната структура и логиката на приложението. Разработчиците имат достъп до кода и проучват всеки модул и функционалност, за да открият потенциални грешки и дефекти. Този вид тестване е също така известен като структурно тестване и помага за осигуряване на качеството на кода. 
Тестването на "черната кутия" пък се извършва без познание на вътрешната структура на приложението. Тестващите лица проверяват функционалността на приложението като цяло, като се фокусират върху входните и изходните данни и очаквания резултат. Този вид тестване е съсредоточен върху функционалността и потребителското изживяване. 
В случаите, когато са открити промени или дефекти, са извършени корекции и тестовете се повторят, за да се увери, че цялостното приложение е качествено и стабилно. Това осигурява, че приложението работи надеждно и отговаря на очакванията на своите потребителите.


      3. Заключение


      7. Постигнати цели


Разразботването на уеб базирано приложение в сферата на геймниг хардуерните продукти, на име Technoworld, бе успешно осъществено, като бяха постигнати абсолютно всички предварително зададени критерии и цели. 
През целия процес на разработка на активен фокус беше създаването на иновативно и адаптивно уеб приложение, което да предложи на потребителите най-доброто потребителско 
изживяване, независимо от техните устройства. Със специално внимание към детайлите и функционалностите, успешно се разработи уеб платформа с чист, разбираем и лесен за поддръжка код, която не само оптимизира функционирането и разширяването на приложението, но и предоставя на потребителите удобен и интуитивен интерфейс за лесна навигация и приятно изживяване. 
Също така бяха създадени и имплементирани всички необходими и зададени функционалности, като функционалността за търсене на продукти например, която предоставя на потребителите разнообразни критерии за ефективно търсене и намиране на най-подходящите продукти за тях. Освен това, успешно се внедри възможността за оценяване на продуктите, което допринася за по-добро разбиране на качеството и популярността на даден продукт, като това улеснява решението на потребителите при избора му. 
Накрая, но определено не и на последно място, беше имплементирана уникалната и за първи път присъстваща в този тип онлайн магазин функционалност, а именно наддаването на специални продукти. Тази неповторима функционалност определено не беше никак лесна за имплементация, но все пак тя беше интегрирана в онлайн платформата успешно. Тя беше направена с цел не само да предоставя на потребителите допълнително удоволствие и ангажимент, но и да се експериментира с интеграцията на други, по-вълнуващи и уникални начини за получаване / печелене на продукти, което като цяло да успее да повиши потребителското удовлетворение и лоялността към платформата.


      8. Потенциално развитие


Въпреки че приложението е напълно практично и работещо по начина, по който се очаква да работи един онлайн магазин, все пак в бъдеще може да се добавят някои нови функционалности, или да се подобрят и актуализират вече същестуващи такива, за да може уебсайта да стане по-добър, ефикасен, удобен и лесен за навигиране от страна на потребителите. Ето и някои от тях:


      * Разширяване на продуктовия пазар- Тъй като уебсайта в момента предлага само и единствено гейминг хардуерни продукти, то обхваща само лимитирани категории и продукти. Под разширяване на продуктовия пазар се има предвид предлагане на повече и по-разнообразни категории и продукти, които са част от тези категории. Например в бъдеще уеб приложението може да предлага както много повече и по-специализирани
      * гейминг хардуерни продукти, така и да предлага и други продукти, като софтуерни продутки (много и най-различни игри, лицензи за операционни системи и др) 
      * не-геймиг, но все пак електрически tech продукти като AR / VR headset-и, смарт часовници, таблети, климатици, Bluetooth колони, мотори, скутери, аудио системи и много други


      * Подобряване на интернализацията - Уебсайта може да се разглежда на 2 езика (английски и български), а цената на продуктите да се показва на 3 различни валути (долар, лев и евро). Това засега е достатъчно, но определено в бъдеще е необходимо да се добавят по-голям и разнообразен каталог от езици и валути, за да може приложението да бъде по-интернализирано и да достига до колкото се може повече хора по света, които с лекота да персонализират езика и валутата на уебсайта така, че да им е удобно и практично.


      * Добавяне на повече опции за плащане на поръчки- Поръчки могат да се плащат само и единствено чрез кредитна / дебитна карта, Paypal, Google Pay или Apple Pay. Трябва на клиента да се даде по-голям избор за това как и чрез какво third-party приложение да извършва своите плащания, затова определено би било хубаво да се добавят повече опции, като разсрочено плащане (чрез приложения като Klarna), банково плащане (чрез приложение на съответната банка на потребителя), други подобни приложения на Paypal (като CashApp Pay и Revolut Pay), наложен платеж (след получаване на поръчката на адрес) и т.н.


      * Изцяло нов и ребрандиран начин за предлагане на продукти- В момента се предлагат продукти, които са в същата категория като разглеждания продукт. Тази система за предлагане на продукти не е много добра, тъй като не е персонализирана достатъчно за дадения потребител. За да може потребителя да получава по-персонализирани предлагани продукти, и да има по-голям шанс той да си закупи някой от тях, е необходимо да се изгради изцяло нова система да предлагане. Освен категорията на продукта, тази интеграция трябва да взема предвид и други по-комплексни фактори, като последните поръчки направени от дадения клиент, последните разглеждани от този потребителя продукти, рейтинга и популярността на продуктите, процентта на продажбите за всеки продукт и др. 
      4. Източници[u]
      1. Анализ на Базата данни от типа ключ-стойност Redis: https://aws.amazon.com/redis/
      2. Предимства и недостатъци на релационната база данни MySQL: https://blueclawdb.com/mysql/advantages-disadvantages-mysql/ 
      3. Предимства и недостатъци на сървърната технология Nest.js: https://bradbeighton.medium.com/nestjs-the-pros-and-cons-aff714607b07 
      4. Описание на front-end технологията Astro: https://www.contentful.com/blog/what-is-astro/
      5. Положителни и отрицателни характеристики на сървърната технология Express.js: https://data-flair.training/blogs/expressjs-advantages-and-disadvantages/ 
      6. Анализ, описание и извличане на позитиви и негативи на front-end технологията Astro: https://www.devinterface.com/en/blog/astro-everything-about-framework
      7. Описание на софтуерната архитектура MVC: https://developer.mozilla.org/en-US/docs/Glossary/MVC
      8. Основни характеристики и описание на MySQL: https://en.wikipedia.org/wiki/MySQL 
      9. Анализ на софтуерната архитектура MVC: https://www.geeksforgeeks.org/mvc-framework-introduction/
      10. Статия за сървърната технология Express.js: https://kinsta.com/knowledgebase/what-is-express-js/ 
      11. Плюсове и минуси на документната база дани MongoDB: https://www.knowledgenile.com/blogs/pros-and-cons-of-mongodb 
      12. Описание и характеристики на сървърната технология Koa.js: https://madushaprasad21.medium.com/next-generation-web-framework-for-node-js-koa-js-ed1f37f1868a 
      13. Анализ на етапите за разработка на уеб базирано приложение: https://www.orientsoftware.com/blog/web-application-development-process/
      14. Предимства и недостатъци на Next.js: https://pagepro.co/blog/pros-and-cons-of-nextjs/
      15. Описание на front-end технологията Nuxt.js: https://www.sanity.io/glossary/nuxt
      16. Описание на етапите за разработка на онлайн приложение: https://seomax.bg/etapi-na-izrabotkata-na-website/
      17. Описание на MVC моделът: https://softuni.bg/blog/what-is-model-view-controller-architecture-pattern
      18. Описание и анализ на сървърните технологии като цяло: https://www.studysmarter.co.uk/explanations/computer-science/computer-network/server-side-technologies/
      19. Статия за различните етапи за разработка на онлайн приложение: https://www.techosquare.com/blog/web-app-development-process-model
      20. Изкуственият интелект ChatGPT: https://chat.openai.com/


      5. Приложение[v]
  







  



  





  



  





  

                2




[a]детайли
[b]имаш повторение на очакванията
[c]Освен това позволява (вместо Тя също....)
[d]Както на статични, така и на динамични...
[e]Махни Въпреки че, започни направо Express.js…. и редактирай края на изречението  , но той не включва...
[f]поддържани
[g]ето така ще изглежда като се подравни двустранно!!! Оправи навсякъде!
[h]На всички места, където имаш нещо посочено в скоби го отлепи от текста, както съм ти го редактирала тук!
[i]Най-предпочитаната
[j]Оправи стила на заглавието, като останалите
[k]Който се използва....
[l]форматиране
[m]останалите, а именно.....
[n]оправи изречението
[o]форматиране на заглавието
[p]При описанието в тази точка, сложи коя фигура от Приложенията отговаря на съответното описание.
И това за следващите секции в този раздел.
[q]форматиране
[r]надписите на фигурите са с много голям шрифт, спрямо останалия текст – това е навсякъде, съобрази го и го оправи
[s]заглавието
[t]тази картинка я нагласи да се вижда по-добре, дори и да заеме цялата страница, защото е ключова в описанието.
[u]Източниците се номерират, а не с тирета, а освен това се слага кратко пояснение кой линк за какво е, т.е. 1.Анализ на ...софтуер (или книга за .... ), или MVC  и чак тогава се слага линка за нещото– линка, който си използвал
[v]Посочените картинки в приложението, къде са цитирани в текстовата част? И на всички картинки оправи текста под тях.